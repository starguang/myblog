---
  time: 2023/01/12
---
# nginx刷新端口丢失问题

最近做了一个项目，因为项目不大，就想着先不申请域名了，直接暴露出端口来用服务器的公网IP来访问（不过这样是有一定的安全隐患的，如果可以选的话最好不要这样）。

我们是用docker来打包的nginx来做反代和前端代码的部署的，不过因为这个服务器有一些部署的内容了，所以无法直接监听80端口，所以用的8087去映射docker里的80端口：

```bash
sudo docker run -dit -p 8087:80 --name xxx xxx
```

搞定完事，访问ip:8087，发现正常访问，圆满结束。

不过事情没有那么简单，当我刷新的时候发现只有IP了，后面的端口不见了。这个是怎么回事？没有端口单纯用IP访问80端口肯定是不回被允许的。然后就切换了很多页面，发现只要刷新就会丢失端口。

这个就很诡异了，于是去搜了一下，发现确实有相同的问题，大部分的解决方式都是加一行配置代码：

```nginx
proxy_set_header Host $host:$server_port; #这里是重点,这样配置才不会丢失端口
```

但是我经过实践发现这个方式不管用，貌似是因为我们这里用的是docker，所以就没办法这样配置，于是就去找运维帮忙排查一下，有什么好的方式去解决。运维排查之后就说container发生了重定向，把原来的8087端口重定向到了80端口，需要docker内的端口和监听的服务器的端口修改成一样的就能解决：

```bash
sudo docker run -dit -p 8087:8087 --name xxx xxx
```

但是我挺想知道为啥的，于是运维就帮我解释了下：

> try_files 执行的时候，它触发了重定向，它生成重定向地址的时候肯定是看自己的配置，也就是 80 端口，它不知道你映射的 8888 端口。 你之前那个  proxy_header 和 try_files 互相独立，两个没有关系。 以往能够生效是因为 映射的端口也是 80，容器端口也是 80，所以重定向就没有问题。
>
> 常规做法是通过主机上的 Nginx 反向代理你的 8888 端口，链路是 user -> Host Nginx 80 -> Docker 8888 -> Container Nginx 80，这样重定向也没问题。 现在直接暴露 8888 了，所以 Container 也要用 8888。

不过我总觉着这样的结局方案不太好，比较dirty，因为不能现在container总是配合服务器的端口去修改，这样很容易就产生问题。于是继续去寻找更方便也更简单的解决方案，最终还真让我找到了：

> nginx配置添加absolute_redirect off; ，可以取消绝对路径的重定向
>
> [1]: http://www.weizhoujie.top/2021/03/12/nginx/
>

然后我就按照这样的方式去修改，确实也可以很好的解决问题。

至此，这个问题得到完美的解决。

\- [1] [魏周杰的博客](http://www.weizhoujie.top/2021/03/12/nginx/)。
